package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"sync"
	"time"

	"github.com/spcent/plumego/contract"
	"github.com/spcent/plumego/core"
	"github.com/spcent/plumego/router"
)

// ================================================
// 1. å®šä¹‰æ•°æ®æ¨¡å‹
// ================================================

type User struct {
	ID        string    `json:"id"`
	Name      string    `json:"name"`
	Email     string    `json:"email"`
	Status    string    `json:"status"`
	Role      string    `json:"role"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// ================================================
// 2. å†…å­˜å­˜å‚¨ Repository (æ— éœ€çœŸå®æ•°æ®åº“)
// ================================================

type InMemoryUserRepository struct {
	users map[string]*User
	mu    sync.RWMutex
}

func NewInMemoryUserRepository() *InMemoryUserRepository {
	repo := &InMemoryUserRepository{
		users: make(map[string]*User),
	}

	// åˆå§‹åŒ–ç¤ºä¾‹æ•°æ®
	now := time.Now()
	repo.users = map[string]*User{
		"user-1": {ID: "user-1", Name: "Alice Johnson", Email: "alice@example.com", Status: "active", Role: "admin", CreatedAt: now, UpdatedAt: now},
		"user-2": {ID: "user-2", Name: "Bob Smith", Email: "bob@example.com", Status: "active", Role: "user", CreatedAt: now, UpdatedAt: now},
		"user-3": {ID: "user-3", Name: "Charlie Brown", Email: "charlie@example.com", Status: "active", Role: "user", CreatedAt: now, UpdatedAt: now},
		"user-4": {ID: "user-4", Name: "Diana Prince", Email: "diana@example.com", Status: "active", Role: "user", CreatedAt: now, UpdatedAt: now},
		"user-5": {ID: "user-5", Name: "Eve Davis", Email: "eve@example.com", Status: "inactive", Role: "user", CreatedAt: now, UpdatedAt: now},
	}

	return repo
}

func (r *InMemoryUserRepository) FindAll(ctx context.Context, params *router.QueryParams) ([]User, int64, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	// è½¬æ¢ä¸ºåˆ‡ç‰‡
	var users []User
	for _, user := range r.users {
		// åº”ç”¨è¿‡æ»¤
		if len(params.Filters) > 0 {
			match := true
			if status, ok := params.Filters["status"]; ok && user.Status != status {
				match = false
			}
			if role, ok := params.Filters["role"]; ok && user.Role != role {
				match = false
			}
			if !match {
				continue
			}
		}

		// åº”ç”¨æœç´¢
		if params.Search != "" {
			if !contains(user.Name, params.Search) && !contains(user.Email, params.Search) {
				continue
			}
		}

		users = append(users, *user)
	}

	total := int64(len(users))

	// åº”ç”¨åˆ†é¡µ
	start := params.Offset
	end := params.Offset + params.Limit
	if start > len(users) {
		return []User{}, total, nil
	}
	if end > len(users) {
		end = len(users)
	}

	return users[start:end], total, nil
}

func (r *InMemoryUserRepository) FindByID(ctx context.Context, id string) (*User, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	user, ok := r.users[id]
	if !ok {
		return nil, fmt.Errorf("user not found")
	}

	return user, nil
}

func (r *InMemoryUserRepository) Create(ctx context.Context, user *User) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	if _, exists := r.users[user.ID]; exists {
		return fmt.Errorf("user already exists")
	}

	r.users[user.ID] = user
	return nil
}

func (r *InMemoryUserRepository) Update(ctx context.Context, id string, user *User) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	if _, exists := r.users[id]; !exists {
		return fmt.Errorf("user not found")
	}

	r.users[id] = user
	return nil
}

func (r *InMemoryUserRepository) Delete(ctx context.Context, id string) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	if _, exists := r.users[id]; !exists {
		return fmt.Errorf("user not found")
	}

	delete(r.users, id)
	return nil
}

func (r *InMemoryUserRepository) Count(ctx context.Context, params *router.QueryParams) (int64, error) {
	users, _, _ := r.FindAll(ctx, params)
	return int64(len(users)), nil
}

func (r *InMemoryUserRepository) Exists(ctx context.Context, id string) (bool, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	_, exists := r.users[id]
	return exists, nil
}

func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(substr) == 0 ||
		(len(s) > 0 && len(substr) > 0 && s[:len(substr)] == substr) ||
		(len(s) > len(substr) && contains(s[1:], substr)))
}

// ================================================
// 3. å®ç°ç”Ÿå‘½å‘¨æœŸé’©å­
// ================================================

type UserHooks struct {
	router.NoOpResourceHooks
}

func (h *UserHooks) BeforeCreate(ctx context.Context, data any) error {
	user := data.(*User)

	// è®¾ç½®æ—¶é—´æˆ³
	now := time.Now()
	user.CreatedAt = now
	user.UpdatedAt = now

	// ç”Ÿæˆ ID
	if user.ID == "" {
		user.ID = fmt.Sprintf("user-%d", now.UnixNano())
	}

	// è®¾ç½®é»˜è®¤å€¼
	if user.Status == "" {
		user.Status = "active"
	}
	if user.Role == "" {
		user.Role = "user"
	}

	log.Printf("[âœ“] Creating user: %s (%s)", user.Name, user.Email)
	return nil
}

func (h *UserHooks) AfterCreate(ctx context.Context, data any) error {
	user := data.(*User)
	log.Printf("[âœ“] User created: %s (ID: %s)", user.Name, user.ID)
	return nil
}

func (h *UserHooks) BeforeUpdate(ctx context.Context, id string, data any) error {
	user := data.(*User)
	user.UpdatedAt = time.Now()
	log.Printf("[âœ“] Updating user: %s", id)
	return nil
}

func (h *UserHooks) AfterDelete(ctx context.Context, id string) error {
	log.Printf("[âœ“] User deleted: %s", id)
	return nil
}

// ================================================
// 4. å®ç°æ•°æ®è½¬æ¢å™¨
// ================================================

type UserTransformer struct{}

func (t *UserTransformer) Transform(ctx context.Context, resource any) (any, error) {
	user := resource.(*User)
	return map[string]any{
		"id":         user.ID,
		"name":       user.Name,
		"email":      user.Email,
		"status":     user.Status,
		"role":       user.Role,
		"created_at": user.CreatedAt.Format(time.RFC3339),
		"updated_at": user.UpdatedAt.Format(time.RFC3339),
	}, nil
}

func (t *UserTransformer) TransformCollection(ctx context.Context, resources any) (any, error) {
	users := resources.([]User)
	result := make([]map[string]any, len(users))
	for i, user := range users {
		transformed, err := t.Transform(ctx, &user)
		if err != nil {
			return nil, err
		}
		result[i] = transformed.(map[string]any)
	}
	return result, nil
}

// ================================================
// 5. é€‚é…å™¨ - å°†å†…å­˜ä»“åº“é€‚é…ä¸ºé€šç”¨ä»“åº“æ¥å£
// ================================================

type UserController struct {
	*router.BaseContextResourceController
	repo *InMemoryUserRepository
}

func NewUserController(repo *InMemoryUserRepository) *UserController {
	ctrl := &UserController{
		BaseContextResourceController: router.NewBaseContextResourceController("user"),
		repo:                           repo,
	}

	// é…ç½®æŸ¥è¯¢å‚æ•°
	ctrl.QueryBuilder.
		WithPageSize(10, 50).
		WithAllowedSorts("name", "email", "created_at", "updated_at").
		WithAllowedFilters("status", "role")

	// é…ç½®é’©å­å’Œè½¬æ¢å™¨
	ctrl.Hooks = &UserHooks{}
	ctrl.Transformer = &UserTransformer{}

	return ctrl
}

// è¦†ç›– CRUD æ–¹æ³•ä»¥ä½¿ç”¨å†…å­˜ä»“åº“
func (c *UserController) IndexCtx(ctx *contract.Ctx) {
	params := c.QueryBuilder.Parse(ctx.R)

	if err := c.Hooks.BeforeList(ctx.R.Context(), params); err != nil {
		ctx.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
		return
	}

	results, total, err := c.repo.FindAll(ctx.R.Context(), params)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to fetch records"})
		return
	}

	transformedResults, err := c.Transformer.TransformCollection(ctx.R.Context(), results)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to transform results"})
		return
	}

	if err := c.Hooks.AfterList(ctx.R.Context(), params, transformedResults); err != nil {
		ctx.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
		return
	}

	pagination := router.NewPaginationMeta(params.Page, params.PageSize, total)

	ctx.JSON(http.StatusOK, router.PaginatedResponse{
		Data:       transformedResults,
		Pagination: pagination,
	})
}

func (c *UserController) ShowCtx(ctx *contract.Ctx) {
	id := c.ParamExtractor.GetHandlerID(ctx.R)
	if id == "" {
		ctx.JSON(http.StatusBadRequest, map[string]string{"error": "ID is required"})
		return
	}

	result, err := c.repo.FindByID(ctx.R.Context(), id)
	if err != nil {
		ctx.JSON(http.StatusNotFound, map[string]string{"error": "Record not found"})
		return
	}

	transformedResult, err := c.Transformer.Transform(ctx.R.Context(), result)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to transform result"})
		return
	}

	ctx.JSON(http.StatusOK, transformedResult)
}

func (c *UserController) CreateCtx(ctx *contract.Ctx) {
	var data User

	if err := ctx.BindJSON(&data); err != nil {
		ctx.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid request body"})
		return
	}

	if err := c.Hooks.BeforeCreate(ctx.R.Context(), &data); err != nil {
		ctx.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
		return
	}

	if err := c.repo.Create(ctx.R.Context(), &data); err != nil {
		ctx.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to create record"})
		return
	}

	if err := c.Hooks.AfterCreate(ctx.R.Context(), &data); err != nil {
		ctx.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
		return
	}

	transformedResult, err := c.Transformer.Transform(ctx.R.Context(), &data)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to transform result"})
		return
	}

	ctx.JSON(http.StatusCreated, transformedResult)
}

func (c *UserController) UpdateCtx(ctx *contract.Ctx) {
	id := c.ParamExtractor.GetHandlerID(ctx.R)
	if id == "" {
		ctx.JSON(http.StatusBadRequest, map[string]string{"error": "ID is required"})
		return
	}

	var data User
	if err := ctx.BindJSON(&data); err != nil {
		ctx.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid request body"})
		return
	}

	data.ID = id

	if err := c.Hooks.BeforeUpdate(ctx.R.Context(), id, &data); err != nil {
		ctx.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
		return
	}

	if err := c.repo.Update(ctx.R.Context(), id, &data); err != nil {
		ctx.JSON(http.StatusNotFound, map[string]string{"error": "Record not found"})
		return
	}

	if err := c.Hooks.AfterUpdate(ctx.R.Context(), id, &data); err != nil {
		ctx.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
		return
	}

	transformedResult, err := c.Transformer.Transform(ctx.R.Context(), &data)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to transform result"})
		return
	}

	ctx.JSON(http.StatusOK, transformedResult)
}

func (c *UserController) DeleteCtx(ctx *contract.Ctx) {
	id := c.ParamExtractor.GetHandlerID(ctx.R)
	if id == "" {
		ctx.JSON(http.StatusBadRequest, map[string]string{"error": "ID is required"})
		return
	}

	if err := c.Hooks.BeforeDelete(ctx.R.Context(), id); err != nil {
		ctx.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
		return
	}

	if err := c.repo.Delete(ctx.R.Context(), id); err != nil {
		ctx.JSON(http.StatusNotFound, map[string]string{"error": "Record not found"})
		return
	}

	if err := c.Hooks.AfterDelete(ctx.R.Context(), id); err != nil {
		ctx.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
		return
	}

	ctx.W.WriteHeader(http.StatusNoContent)
}

// ================================================
// 6. ä¸»å‡½æ•°
// ================================================

func main() {
	// åˆ›å»ºåº”ç”¨
	app := core.New(
		core.WithAddr(":8080"),
		core.WithDebug(),
		core.WithRequestID(),
		core.WithLogging(),
		core.WithRecovery(),
		core.WithCORS(),
	)

	// åˆ›å»ºå†…å­˜ä»“åº“
	repo := NewInMemoryUserRepository()

	// æ³¨å†Œè·¯ç”±
	registerRoutes(app.Router(), repo)

	// å¯åŠ¨æœåŠ¡å™¨
	log.Println("========================================")
	log.Println("ğŸš€ CRUD Framework Demo (In-Memory)")
	log.Println("========================================")
	log.Println("Server: http://localhost:8080")
	log.Println("")
	log.Println("ğŸ“š Available endpoints:")
	log.Println("  GET    /                - Welcome page")
	log.Println("  GET    /users           - List users")
	log.Println("  GET    /users/:id       - Get user")
	log.Println("  POST   /users           - Create user")
	log.Println("  PUT    /users/:id       - Update user")
	log.Println("  DELETE /users/:id       - Delete user")
	log.Println("")
	log.Println("========================================")

	if err := app.Boot(); err != nil {
		log.Fatalf("Server failed: %v", err)
	}
}

func registerRoutes(r *router.Router, repo *InMemoryUserRepository) {
	// é¦–é¡µ
	r.GetHandler("/", func(w http.ResponseWriter, req *http.Request) {
		html := `<!DOCTYPE html>
<html>
<head>
    <title>CRUD Demo</title>
    <style>
        body { font-family: Arial; max-width: 900px; margin: 50px auto; padding: 20px; }
        h1 { color: #333; }
        .endpoint { background: #f5f5f5; padding: 15px; margin: 10px 0; border-radius: 5px; }
        code { background: #e9ecef; padding: 2px 5px; border-radius: 3px; }
    </style>
</head>
<body>
    <h1>ğŸš€ CRUD Framework Demo</h1>
    <p>Try these commands:</p>
    <div class="endpoint">
        <code>curl http://localhost:8080/users</code> - List all users
    </div>
    <div class="endpoint">
        <code>curl http://localhost:8080/users/user-1</code> - Get single user
    </div>
    <div class="endpoint">
        <code>curl -X POST http://localhost:8080/users -H "Content-Type: application/json" -d '{"name":"Test","email":"test@example.com"}'</code> - Create user
    </div>
</body>
</html>`
		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		w.Write([]byte(html))
	})

	// ç”¨æˆ· CRUD
	ctrl := NewUserController(repo)
	r.GetHandlerCtx("/users", ctrl.IndexCtx)
	r.GetHandlerCtx("/users/:id", ctrl.ShowCtx)
	r.PostCtx("/users", ctrl.CreateCtx)
	r.PutCtx("/users/:id", ctrl.UpdateCtx)
	r.DeleteCtx("/users/:id", ctrl.DeleteCtx)
}
