# 数据库分库分表规划总结

## 📋 执行摘要

本文档是 plumego 数据库分库分表功能的规划总结,涵盖完整的技术设计、API 定义和实施路线图。

### 项目目标

为 `store/db` 包添加企业级数据库中间件能力:
- ✅ **读写分离**: 主从架构,自动路由读写请求
- ✅ **分库分表**: 水平分片,支持多种分片策略
- ✅ **业务透明**: 通过统一接口屏蔽底层复杂性
- ✅ **高可用**: 故障转移、健康检查、自动恢复
- ✅ **可观测**: 完整监控指标和分布式追踪

### 核心价值

1. **性能提升**: 通过分片突破单库性能瓶颈
2. **高可用**: 主从架构提供故障容错
3. **无缝集成**: 与现有 plumego 架构完美融合
4. **开发友好**: API 简洁,业务代码零改动
5. **生产就绪**: 完整的监控、告警、故障排查

---

## 📚 文档结构

### 1. SHARDING_DESIGN.md (设计方案)

**内容概要**:
- 整体架构设计
- 模块划分和职责
- 读写分离详细设计
- 分片策略详细设计
- 监控和可观测性
- 安全考虑和限制

**适用读者**: 架构师、技术负责人、核心开发人员

**关键章节**:
- 第 3 章: 架构设计 - 了解整体架构
- 第 4 章: 读写分离设计 - 主从架构实现
- 第 5 章: 分库分表设计 - 分片策略和路由
- 第 9 章: 实现计划 - 分阶段实施

### 2. SHARDING_API.md (API 接口)

**内容概要**:
- 完整的接口定义
- 6+ 个实际使用场景
- 代码示例和最佳实践
- 故障排查指南
- 性能调优建议

**适用读者**: 应用开发人员、运维人员

**关键章节**:
- 第 1 章: 核心接口定义 - API 参考
- 第 2 章: 使用示例 - 学习如何使用
- 第 5 章: 最佳实践 - 避免常见陷阱
- 第 6 章: 故障排查 - 解决问题

### 3. ROADMAP.md (实施路线)

**内容概要**:
- 详细的时间规划 (12 周)
- 4 个阶段里程碑
- 具体任务分解
- 风险和缓解措施
- 成功指标

**适用读者**: 项目经理、开发团队

**关键章节**:
- 阶段 1-4: 实施计划 - 按周分解任务
- 风险和缓解: 提前识别问题
- 发布检查清单: 确保质量

---

## 🏗️ 技术架构概览

### 整体架构

```
业务层 (透明使用)
    ↓
路由层 (SQL 解析 + 分片路由 + 读写分离)
    ↓
连接层 (分片集群 + 主从集群)
    ↓
数据库 (多个物理数据库实例)
```

### 核心组件

| 组件 | 职责 | 位置 |
|------|------|------|
| `Router` | 统一路由器,整合所有路由逻辑 | `store/db/router.go` |
| `ReadWriteCluster` | 读写分离集群管理 | `store/db/readwrite/splitter.go` |
| `ShardingStrategy` | 分片策略接口和实现 | `store/db/sharding/strategy.go` |
| `LoadBalancer` | 负载均衡器 | `store/db/readwrite/loadbalancer.go` |
| `ShardKeyResolver` | 分片键解析 | `store/db/sharding/resolver.go` |
| `SQLRewriter` | SQL 改写(分表场景) | `store/db/router.go` |
| `HealthChecker` | 健康检查 | `store/db/readwrite/health.go` |

### 目录结构

```
store/db/
├── sql.go                    # 现有基础包 ✅
├── cluster.go                # 集群管理 [NEW]
├── router.go                 # 统一路由器 [NEW]
├── readwrite/                # 读写分离 [NEW]
│   ├── splitter.go
│   ├── loadbalancer.go
│   ├── policy.go
│   └── health.go
├── sharding/                 # 分片功能 [NEW]
│   ├── strategy.go
│   ├── hash.go
│   ├── range.go
│   ├── mod.go
│   ├── list.go
│   └── resolver.go
├── SHARDING_DESIGN.md        # 设计文档 ✅
├── SHARDING_API.md           # API 文档 ✅
├── ROADMAP.md                # 实施路线 ✅
└── PLANNING_SUMMARY.md       # 本文档 ✅
```

---

## 🚀 快速开始

### 读写分离示例

```go
db, err := cluster.New(cluster.Config{
    Primary: &cluster.DataSource{
        Driver: "mysql",
        DSN:    "user:pass@tcp(primary:3306)/db",
    },
    Replicas: []cluster.DataSource{
        {Driver: "mysql", DSN: "user:pass@tcp(replica:3306)/db"},
    },
    EnableReadWrite: true,
})

// 写操作 -> 主库
db.ExecContext(ctx, "INSERT INTO users (name) VALUES (?)", "Alice")

// 读操作 -> 从库
rows, _ := db.QueryContext(ctx, "SELECT * FROM users")
```

### 分片示例

```go
db, err := cluster.New(cluster.Config{
    EnableSharding: true,
    Shards: []cluster.ShardConfig{
        {Index: 0, Primary: ..., Replicas: ...},
        {Index: 1, Primary: ..., Replicas: ...},
    },
    ShardingRules: []cluster.ShardingRule{
        {
            TableName:      "users",
            ShardKeyColumn: "user_id",
            Strategy:       sharding.NewHashStrategy(),
            NumShards:      2,
        },
    },
})

// 自动路由到分片
db.ExecContext(ctx, "INSERT INTO users (user_id, name) VALUES (?, ?)", 12345, "Bob")
```

---

## 📅 实施时间表

### 总体规划: 12 周

| 阶段 | 时间 | 核心功能 | 交付物 |
|------|------|----------|--------|
| **阶段 1** | Week 1-3 | 读写分离基础 | 完整的读写分离功能 |
| **阶段 2** | Week 4-7 | 分片基础 | 分片路由 + 4 种策略 |
| **阶段 3** | Week 8-10 | 高级功能 | SQL 改写 + 监控追踪 |
| **阶段 4** | Week 11-12 | 优化发布 | 性能优化 + 文档完善 |

### 关键里程碑

- **Week 3**: 读写分离可用 ✨
- **Week 7**: 分片功能可用 ✨
- **Week 10**: 生产特性完整 ✨
- **Week 12**: 正式发布 v1.0 🎉

---

## 🎯 阶段目标

### 阶段 1: 读写分离 (Week 1-3)

**核心交付**:
- ✅ `ReadWriteCluster` 实现
- ✅ 4 种负载均衡器 (轮询、随机、最少连接、加权)
- ✅ 健康检查和故障转移
- ✅ 单元测试 + docker-compose 集成测试

**验收标准**:
- 写操作路由到主库 ✅
- 读操作路由到从库 ✅
- 从库故障时降级到主库 ✅
- 性能损失 < 5% ✅

### 阶段 2: 分片基础 (Week 4-7)

**核心交付**:
- ✅ 4 种分片策略 (哈希、取模、范围、列表)
- ✅ SQL 解析和分片键提取
- ✅ 统一路由器
- ✅ 跨分片查询处理

**验收标准**:
- 查询自动路由到正确分片 ✅
- 路由决策延迟 < 100μs ✅
- 支持分片 + 读写分离组合 ✅
- 单元测试覆盖率 > 85% ✅

### 阶段 3: 高级功能 (Week 8-10)

**核心交付**:
- ✅ SQL 改写 (物理分表场景)
- ✅ Prometheus 指标
- ✅ OpenTelemetry 追踪
- ✅ YAML 配置加载

**验收标准**:
- SQL 改写正确性 100% ✅
- 监控指标完整 ✅
- 配置管理灵活 ✅

### 阶段 4: 优化发布 (Week 11-12)

**核心交付**:
- ✅ 性能优化 (路由缓存、内存优化)
- ✅ 完整文档 (API、使用指南、故障排查)
- ✅ 生产检查清单

**验收标准**:
- 路由开销 < 50μs ✅
- 文档完整度 100% ✅
- 可以安全用于生产 ✅

---

## 💡 核心特性

### 1. 多种分片策略

| 策略 | 适用场景 | 优点 | 缺点 |
|------|----------|------|------|
| **哈希** | 用户数据、订单数据 | 数据分布均匀 | 范围查询需查所有分片 |
| **范围** | 时间序列、地区数据 | 范围查询高效 | 可能数据倾斜 |
| **取模** | 简单场景、整数键 | 性能极高 | 扩容困难 |
| **列表** | 租户/商户分片 | 灵活可控 | 需维护映射表 |

### 2. 灵活的负载均衡

- **轮询** (Round Robin): 平均分配
- **随机** (Random): 简单快速
- **最少连接** (Least Connections): 动态负载均衡
- **加权轮询** (Weighted): 考虑服务器性能差异

### 3. 智能路由策略

- **SQL 类型识别**: 自动识别读写操作
- **上下文提示**: 支持强制路由到主库
- **事务感知**: 事务中所有操作路由到主库
- **FOR UPDATE 检测**: 自动路由到主库

### 4. 高可用保障

- **健康检查**: 后台定期 ping 检测
- **自动降级**: 从库故障时降级到主库
- **故障恢复**: 自动检测恢复的副本
- **重试机制**: 可配置的重试策略

### 5. 完整的可观测性

- **Prometheus 指标**: 查询数、延迟、错误率、分片分布
- **OpenTelemetry 追踪**: 端到端请求追踪
- **结构化日志**: 详细的路由决策日志
- **健康状态 API**: 实时查询集群健康状态

---

## ⚠️ 限制和注意事项

### 不支持的功能

- ❌ **分布式事务**: 跨分片事务不支持 (需要应用层处理)
- ❌ **跨分片 JOIN**: 需要在应用层实现
- ❌ **跨分片聚合**: SUM/AVG 等需要应用层合并
- ❌ **自动数据迁移**: 扩容需要手动迁移数据

### SQL 解析限制

- 使用轻量级解析 (正则 + 字符串处理)
- 支持常见 SQL 模式
- 复杂 SQL 可能解析失败 (可使用手动路由)

### 性能考虑

- 路由决策有微小开销 (目标 < 50μs)
- 跨分片查询需要内存合并
- SQL 解析有一定 CPU 开销

### 使用建议

1. **分片键必须不可变**: 避免数据迁移
2. **查询尽量包含分片键**: 避免跨分片查询
3. **事务限制在单分片**: 跨分片用最终一致性
4. **定期监控分片均衡性**: 避免数据倾斜

---

## 📊 性能目标

### 核心指标

| 指标 | 目标值 | 测试方法 |
|------|--------|----------|
| 路由决策延迟 (p99) | < 50μs | Go benchmark |
| 吞吐量 | ≥ 单库 95% | 压力测试 |
| 内存开销 | < 10MB | 内存 profiling |
| 并发支持 | 1000+ 连接 | 并发测试 |
| 单元测试覆盖率 | > 85% | `go test -cover` |

### 性能优化策略

1. **路由缓存**: 缓存路由决策结果
2. **对象池**: 使用 `sync.Pool` 减少 GC
3. **原子操作**: 减少锁竞争
4. **字符串优化**: 减少拷贝和分配

---

## 🔒 安全考虑

### 1. SQL 注入防护

- 继承 `database/sql` 的参数绑定
- 不拼接 SQL 字符串
- 分片键提取不执行 SQL

### 2. 访问控制

- 支持不同分片使用不同凭证
- 支持只读用户连接从库

### 3. 审计日志

- 记录所有跨分片查询
- 记录路由决策失败
- 可配置的日志级别

---

## 🛠️ 开发环境准备

### 依赖工具

```bash
# Go 版本
go version  # 1.24+

# Docker (用于测试)
docker --version
docker-compose --version

# 数据库驱动
go get -u github.com/go-sql-driver/mysql
```

### 测试环境搭建

```bash
# 启动 MySQL 主从
cd store/db/testdata
docker-compose up -d

# 运行测试
go test -v ./...

# 性能测试
go test -bench=. -benchmem ./...
```

---

## 📖 学习路径

### 对于应用开发人员

1. 阅读 **SHARDING_API.md** 第 1-2 章 (接口和示例)
2. 运行示例代码 `examples/readwrite/main.go`
3. 阅读 **SHARDING_API.md** 第 5 章 (最佳实践)
4. 参考 **SHARDING_API.md** 第 6 章 (故障排查)

### 对于架构师

1. 阅读 **SHARDING_DESIGN.md** 第 3-6 章 (架构设计)
2. 阅读 **ROADMAP.md** (了解实施计划)
3. 阅读 **SHARDING_DESIGN.md** 第 13 章 (限制和已知问题)
4. 评估是否适合当前业务场景

### 对于开发团队

1. 阅读 **ROADMAP.md** (时间规划和任务分解)
2. 阅读 **SHARDING_DESIGN.md** 第 9 章 (实现计划)
3. 阅读 **SHARDING_DESIGN.md** 第 10 章 (测试策略)
4. 按阶段开始实施

---

## ✅ 下一步行动

### 立即行动

1. **审查规划文档**: 团队评审设计方案
2. **确认资源**: 分配开发人员和时间
3. **准备环境**: 搭建开发和测试环境
4. **创建任务**: 在项目管理工具中创建任务

### 第一周任务

1. **创建目录结构**: `store/db/readwrite/`, `store/db/sharding/`
2. **定义接口**: 实现 `LoadBalancer`, `RoutingPolicy`, `Strategy` 接口
3. **实现 ReadWriteCluster**: 基本的连接管理和路由
4. **编写测试**: 单元测试骨架

### 里程碑检查

- **Week 3 结束**: 读写分离功能演示
- **Week 7 结束**: 分片功能演示
- **Week 10 结束**: 完整功能演示
- **Week 12 结束**: 准备发布

---

## 📞 支持和反馈

### 文档反馈

如果发现文档问题或有改进建议:
1. 在项目中创建 issue
2. 标记 `documentation` 标签
3. 详细描述问题和建议

### 技术讨论

如果有技术问题或设计疑问:
1. 查阅相关文档章节
2. 在团队会议中讨论
3. 必要时更新设计文档

---

## 📝 文档维护

### 版本历史

| 版本 | 日期 | 变更 | 作者 |
|------|------|------|------|
| v1.0 | 2026-01-30 | 初始版本 | Claude AI |

### 文档清单

- ✅ SHARDING_DESIGN.md - 完整设计方案
- ✅ SHARDING_API.md - API 接口和示例
- ✅ ROADMAP.md - 实施路线图
- ✅ PLANNING_SUMMARY.md - 本总结文档

### 更新计划

- 阶段 1 完成后: 更新实际进度
- 阶段 2 完成后: 更新性能数据
- 阶段 3 完成后: 补充监控示例
- 正式发布前: 最终审核所有文档

---

## 🎉 总结

本规划为 plumego 数据库层提供了完整的分库分表解决方案:

✅ **技术可行**: 基于 Go 标准库,架构清晰
✅ **实施明确**: 12 周分阶段实施,风险可控
✅ **文档完整**: 设计、API、路线图三位一体
✅ **质量保证**: 完善的测试和监控策略
✅ **生产就绪**: 考虑高可用、性能、安全

**我们已经准备好开始实施了! 🚀**

---

**文档版本**: v1.0
**创建时间**: 2026-01-30
**状态**: ✅ 规划完成,待审批
**下一步**: 团队审查 → 资源分配 → 开始实施

